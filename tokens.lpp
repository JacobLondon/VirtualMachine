%{
#include <iostream>
#include <cstdlib>
#include "parser.hpp"

template<typename Reg_t>
static Reg_t strToReg(const char* yytext);
%}

%option noyywrap
%option yylineno

%%

[ \t\r\n]   ;
[0-9]+         return NUM;
"["            return LBRACKET;
"]"            return RBRACKET;
","            return COMMA;
"#"            return POUND;
":"            return COLON;
"nop"          return NOP;
"add"          return ADD;
"sub"          return SUB;
"mul"          return MUL;
"div"          return DIV;
"mod"          return MOD;
"nand"         return NAND;
"and"          return AND;
"xnor"         return XNOR;
"xor"          return XOR;
"nor"          return NOR;
"or"           return OR;
"shr"          return SHR;
"shl"          return SHL;
"cmp"          return CMP;
"mov"          return MOV;
"swp"          return SWP;
"li"           return LI;
"set"          return SET;
"clr"          return CLR;
"sw"           return SW;
"lw"           return LW;
"b"            return B;
"call"         return CALL;
"ret"          return RET;

"eq"           return EQ;
"ne"           return NE;
"cs"           return CS;
"hs"           return HS;
"cc"           return CC;
"lo"           return LO;
"mi"           return MI;
"pl"           return PL;
"vs"           return VS;
"hi"           return HI;
"ls"           return LS;
"ge"           return GE;
"gt"           return GT;
"le"           return LE;
"al"           return AL;

"zero"         return ZERO;
"pc"           return PC;
"r"[0-3]?[0-9] return strToReg<ireg>(yytext);
"f"[0-3]?[0-9] return strToReg<freg>(yytext);

"s"            return STATUS;
.              return OTHER;


%%
template<typename Reg_t>
Reg_t strToReg(const char* yytext) {
    long regNum = atol(&yytext[1]);
    if (regNum >= 32) {
        std::cerr << "Error - invalid register: " << yytext << std::endl;
        return OTHER;
    }
    return static_cast<Reg_t>(regNum);
}
